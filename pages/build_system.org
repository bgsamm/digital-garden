:PROPERTIES:
:Title: Build system
:Author: pjsamm
:Date: 2025-12-26
:END:

#+OPTIONS: H:5

#+PROPERTY: header-args    :noweb yes
#+PROPERTY: header-args+   :eval never-export

**** TODO Better handling of heading export level setting
**** TODO Incorporate Jinja templates as literate programs
**** TODO Organize this page!!
**** TODO Better handling of the repeated references to design philosophies (footnotes/sidenotes?)
**** TODO Use ~code~ instead of =verbatim= where appropriate

* Overview

This page details the source code for the build system used to
generate this site. For a more general overview of this site's
design, see [[file:site_overview.org][Site Overview]].

The build system is implemented as a Python script, which generates a
static site from Emacs [[https://orgmode.org/][Org]] files using [[https://boisgera.github.io/pandoc/][Pandoc]] to convert said files to
HTML, and [[https://jinja.palletsprojects.com/en/stable/][Jinja]] for generating pages from templates.

**** TODO Link to "wrap your dependencies" design principle

While it would be possible to use Pandoc from the CLI directly with
its built-in support for filters and templates, that approach couples
me even more tightly to Pandoc, which I consider undesirable.

** Program outline

The overall structure of the program is as follows:

#+begin_src python :tangle ../build.py
  <<Imports>>

  <<Global constants>>

  <<Class definitions>>

  <<Function definitions>>

  <<Prepare build directory>>

  <<Initialize Jinja>>

  <<Process org files>>

  <<Generate home page>>

  <<Export static files>>
#+end_src

**** DONE Add section for pre-build setup

** Class definitions

**** TODO Extract my philosophy on OOP/classes into a better location?

Classes are used primarily as data containers (Ã  la structs in C) and
generally do not define methods beyond their constructors. I have
determined that the improved readability compared to tuples and
improved usability compared to dictionaries is worth the additional
boilerplate.

#+begin_src python :noweb-ref Class definitions
  class OrgTree:
      def __init__(self, metadata, nodes):
          self.metadata = metadata
          self.nodes = nodes

#+end_src 

#+begin_src python :noweb-ref Class definitions
  class OrgNode:
      def __init__(self, type_):
          self.type_ = type_
          self.text = ''
          self.children = []

          self.id_ = None
          self.cls = []
          self.attrs = {}

#+end_src

* Utility functions

The following are a collection of utility functions that will be
useful throughout the build script.

** String utilities

**** DONE Split into "Regex" and "HTML" sections
**** TODO Add reference to "wrap your dependencies"

The functions here provide miscellaneous utilities for working with
strings.

*** Regex utilities

This primarily exists to wrap the =re= library dependency.

#+begin_src python :noweb-ref Imports
  import re
#+end_src

#+begin_src python :noweb-ref Function definitions
  def regex_match(pattern, string):
      """Return the list of match groups for a given regex pattern
      and input string, or None if the string was not a match
      """
      match_obj = re.match(pattern, string)
      if match_obj is not None:
          return match_obj.groups()
      return None

#+end_src

*** HTML utilities

**** TODO Add reference to "reinvent the wheel" (html library)
**** TODO Add support for escaping quotes?

This replaces a dependency on the =html= library.

Note that when escaping strings for use in HTML content, ampersands
should be replaced first, else the ampersands in the angle bracket
escape sequences will also get replaced!

#+begin_src python :noweb-ref Function definitions
  def html_escape(string):
      """Replace the '&', '<', and '>' characters in a string with their
      corresponding HTML escape sequences.
      """
      return string.replace('&', '&amp;') \
                   .replace('<', '&lt;') \
                   .replace('>', '&gt;')

#+end_src

** File system utilities

**** TODO Add link to "wrap your dependencies" mantra

These functions primarily serve to wrap dependencies on the =os= and
=shutil= libraries.

#+begin_src python :noweb-ref Imports
  import os
#+end_src

#+begin_src python :noweb-ref Imports
  import shutil
#+end_src

#+begin_src python :noweb-ref Function definitions
  def path_join(*args):
      """Join several path elements together with the OS-appropriate
      path separator.
      """
      return os.path.join(*args)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def make_dir(path):
      """Create a directory (and all necessary parent directories) if it
      does not already exist.
      """
      os.makedirs(path, exist_ok=True)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def empty_dir(root):
      """Delete the contents of a directory.
      """
      for itemname in os.listdir(root):
          itempath = os.path.join(root, itemname)
          if os.path.isdir(itempath):
              shutil.rmtree(itempath)
          else:
              os.remove(itempath)
#+end_src

#+begin_src python :noweb-ref Function definitions
  def copy_dir(indir, outdir):
      """Copy the contents of one directory to another.
      """
      shutil.copytree(indir, outdir, dirs_exist_ok=True)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def walk_dir(root):
      """Walk recursively through the files in a directory tree,
      yielding for each file its containing directory, name, and
      extension.
      """
      for dirpath, dirnames, filenames in os.walk(root):
          for filename in filenames:
              fname, ext = os.path.splitext(filename)
              yield dirpath, fname, ext

#+end_src

* Preparing the build environment

Before the actual build process can begin, some initial setup must be
performed. First, the build directory must be prepared, and second, a
Jinja environment must be created.

** Preparing the build directory

If the build directory does not exist, it must be created; if it
does exist, its contents must be deleted (to ensure a deleted, moved,
or renamed "zombie" page does not persist between builds).

(This step is trivialized by the utility functions defined above.)

#+begin_src python :noweb-ref Global constants
  BUILD_DIR = 'build'
#+end_src

#+name: Prepare build directory
#+begin_src python
  make_dir(BUILD_DIR)
  empty_dir(BUILD_DIR)
#+end_src

** Initializing Jinja

**** TODO Remove file prefix from link once intra-file links supported

Jinja uses an =Environment= object as a high-level API for configuring
and loading templates. This is created as a global variable for later
use (see [[file:build_system.org::*Populating the HTML template][Populating the HTML template]]) and is set to load templates
from a file system directory and trim whitespace from template blocks
(see [[https://jinja.palletsprojects.com/en/stable/api/#high-level-api][documentation]]).

**** TODO Determine why the library is called jinja*2*

#+begin_src python :noweb-ref Imports
  import jinja2
#+end_src

#+begin_src python :noweb-ref Global constants
  TEMPLATES_DIR = 'templates'
#+end_src

#+name: Initialize Jinja
#+begin_src python
  jinja_env = jinja2.Environment(
      loader=jinja2.FileSystemLoader(TEMPLATES_DIR),
      trim_blocks=True,
      lstrip_blocks=True
  )
#+end_src

* Processing Org files

**** TODO Add reference to "wrap your dependencies"
**** TODO Add reference to "reinvent the wheel" (pandoc.write)

Now that the build environment has been initialized, the process of
actually generating the site's pages can begin. This makes up the bulk
of the build system's complexity, since it includes both a second
parsing pass on the AST generated by Pandoc and a custom HTML
generator in place of =pandoc.write()=.

To start, the directory tree containing the Org files is walked,
filtering for non-hidden files with the '.org' extension (Emacs
automatically creates several different temp/back-up files when
editing that should be ignored).

Processing an Org file then consists of four steps:
1. Parse the file contents into an abstract syntax tree (AST).
2. Generate the page content (as HTML) from the AST.
3. Use that HTML (and any other relevant metadata) to populate a
   static page template.
4. Write the final result to disk.

**** TODO Add link to "Generating the home page"

The resulting pages are tracked for use when generating the
home page.

#+begin_src python :noweb-ref Global constants
  PAGES_DIR = 'pages'
#+end_src

#+name: Process org files
#+begin_src python
  pages = []
  for dirpath, fname, ext in walk_dir(PAGES_DIR):
      if fname[0] == '.' or ext != '.org':
          continue

      <<Parse Org file into AST>>

      <<Generate page content from AST>>

      <<Create page from template>>

      <<Write page to file>>
#+end_src

** Parsing an Org file

**** TODO Eliminate the pandoc dependency once and for all!
**** TODO Insert link to "wrap dependencies" mantra

The procedure for parsing an Org file is wrapped in a function call to
hide the Pandoc dependency, so on the surface it is quite simple:

#+name: Parse Org file into AST
#+begin_src python
  fpath = path_join(dirpath, fname + ext)
  ast = parse_org_file(fpath)
#+end_src

**** TODO Insert link to pandoc library documentation
**** TODO Insert link to to-do handling
**** TODO Better document my knowledge of how Pandoc exports Org files

However, the function itself is rather involved. The =pandoc= library
uses a wide range of custom types to represent the various possible
elements in a document, so to truly hide the dependency from the rest
of the script, these types must all be "unwrapped" and converted to a
library-agnostic format. (The effort is not altogether a waste,
either, as it allows for additional processing to better handle
certain Org-specific elements along the way, such as to-do items.)

At the high level, =pandoc.read()= returns a root =Pandoc= object,
which itself contains a =Meta= object and a list of =Block=
objects as children. The task, then, breaks down into unwrapping these
two elements.

#+begin_src python :noweb-ref Imports
  import pandoc
#+end_src

#+begin_src python :noweb-ref Function definitions
  def parse_org_file(fpath):
      ast = pandoc.read(file=fpath)

      <<Unwrap metadata>>

      <<Unwrap blocks>>

      return OrgTree(metadata, nodes)

#+end_src

*** Unwrapping Pandoc metadata

**** TODO Link to org-mode documentation on property drawers
**** TODO Link to pandoc Python documentation on types
**** TODO Extract thoughts about asserting assumptions into design principles
**** TODO Convert notes to proper footnotes/sidenotes

Every Org file in this repository starts with a property drawer that
defines its metadata, like title, author, date, etc. This populates
the aforementioned =Meta= object, which contains a dictionary of
(=str=, =MetaString=) pairs.

(Note 1: The types used by the =pandoc= library are generally
"list-like," meaning rather than as member variables, attributes are
accessed via indices and slices.)

(Note 2: =assert= statements are used throughout this section of the
script to document my assumptions about how Pandoc parses Org files,
so that it is immediately clear if these assumptions ever turn out to
be incorrect.)

(Note 3: Technically, the type of the dictionary values is defined to
be =MetaValue=, which can be one of many possible child types; I am
presently assuming that in the case of Org files, it always uses
=MetaString=.)

#+name: Unwrap metadata
#+begin_src python
  # Unwrap 'Meta' object
  metadata = ast[0][0]
  for k, v in metadata.items():
      assert(type(v) is pandoc.types.MetaString)
      # Unwrap 'MetaString' object
      metadata[k] = v[0]
#+end_src

*** Unwrapping Pandoc blocks

The second element of the root =Pandoc= object is a list of =Block=
objects, which represent each of the individual blocks in the Org file
as one of several different subtypes (e.g. =Header=, =Para=,
=CodeBlock=, etc.). Filters for each block type are added and expanded
on an as-needed basis.

#+name: Unwrap blocks
#+begin_src python
  nodes = unwrap_blocks(ast[1])
#+end_src

#+begin_src python :noweb-ref Function definitions
  def unwrap_blocks(blocks):
      return [unwrap_block(block) for block in blocks]

#+end_src

To start, an =Enum= is created to represent the various output node
types.

#+begin_src python :noweb-ref Imports
  import enum
#+end_src

#+begin_src python :noweb-ref Class definitions
  class NodeType(enum.Enum):
      CODE = enum.auto()
      HEAD = enum.auto()
      ITEM = enum.auto()
      LINK = enum.auto()
      LIST = enum.auto()
      META = enum.auto()
      PARA = enum.auto()
      SPAN = enum.auto()
      TEXT = enum.auto()
      TODO = enum.auto()
      TOKN = enum.auto()

#+end_src

Then, a map from Pandoc types to the functions responsible for
unwrapping them is set up.

#+begin_src python :noweb-ref Imports
  import pandoc.types as pdt
#+end_src

#+name: Pandoc type unwrapping map
#+begin_src python :noweb-ref
  pandoc_type_map = {
      pdt.Code: unwrap_code,
      pdt.CodeBlock: unwrap_code,
      pdt.Emph: unwrap_textblock,
      pdt.Header: unwrap_head_or_para,
      pdt.Link: unwrap_link_or_span,
      pdt.OrderedList: unwrap_list,
      pdt.Para: unwrap_head_or_para,
      pdt.Plain: unwrap_textblock,
      pdt.RawBlock: unwrap_rawblock,
      pdt.SoftBreak: unwrap_token,
      pdt.Space: unwrap_token,
      pdt.Span: unwrap_link_or_span,
      pdt.Str: unwrap_token,
      pdt.Strong: unwrap_textblock
  }
#+end_src

Code blocks are represented by =CodeBlock= objects, which consist of
an =Attr= tuple and the contained code (text). The language is
specified in the class list of the =Attr= tuple.

**** DONE Determine whether attributes list contains anything useful
**** DONE Verify whether language is only element of class list

Inline code blocks are represented by ~Code~ objects and consist of an
=Attr= tuple and the contained code (text).

**** DONE Determine significance of 'verbatim' class
**** DONE Verify whether rest of =Attr= tuple goes unused

#+begin_src python :noweb-ref Function definitions
  def unwrap_code(block):
      node = OrgNode(NodeType.CODE)
      node.text = block[1]
      node.inline = (type(block) is pdt.Code)
      node.id_, node.cls, node.attrs = block[0]

      return node

#+end_src

**** TODO Determine whether 'tokens' is really the appropriate term

=Header= objects contain the header level (1, 2, 3, etc.), an =Attr=
tuple of the form (id, classes, attributes), and then a list
representing the parsed header tokens (type =Inline=). These must be
unwrapped recursively.

Because =TODO= items are represented in an Org mode using the same
syntax as headings, they end up getting parsed as a =Span= in either a
=Header= or a =Para= object's =Inline= tokens (since Pandoc exports
headings deeper than =org-export-headline-levels= as paragraphs).

**** DONE Verify whether the class and attribute lists are unused
**** DONE Clean up TODO detection/unwrapping logic

#+begin_src python :noweb-ref Function definitions
  def unwrap_head_or_para(block):
      if type(block) is pdt.Header:
          node = OrgNode(NodeType.HEAD)
          node.level = block[0]
          node.id_, node.cls, node.attrs = block[1]
          i = 2
      else:
          node = OrgNode(NodeType.PARA)
          i = 0

      node.children = unwrap_blocks(block[i])

      is_todo = 'todo' in node.children[0].cls
      is_done = 'done' in node.children[0].cls
      if is_todo or is_done:
          node.type_ = NodeType.TODO
          node.done = is_done
          del node.children[0]

      return node

#+end_src

=Link= objects contain an =Attr= tuple, a list of =Inline= tokens (the
link text), and the link's =Target= (a 2-tuple).

**** DONE Verify whether the Attr tuple is unused
**** DONE Verify that second element of Target is title (and unused)
**** TODO Pandoc categories certain valid internal links as "spurious" and emits them as spans; add custom handling for these

=Span= objects consist of an =Attr= tuple and a list of =Inline=
tokens, much like a header. This gets emitted for =TODO= items, in
which case the class list in the =Attr= tuple will be =['todo',
'TODO']=.

**** TODO Determine under what other circumstances Span gets emitted
**** DONE Check how 'DONE' tasks get emitted

#+begin_src python :noweb-ref Function definitions
  def unwrap_link_or_span(block):
      if type(block) is pdt.Link:
          node = OrgNode(NodeType.LINK)
          node.target = block[2][0]
          # Appears to be unused
          node.title = block[2][1]
      else:
          node = OrgNode(NodeType.SPAN)

      node.id_, node.cls, node.attrs = block[0]
      node.children = unwrap_blocks(block[1])

      return node

#+end_src

An =OrderedList= contains a tuple of list attributes of the form
(start, style, delim), then a list of the list's items (each of which
is itself a list of blocks).

#+begin_src python :noweb-ref Function definitions
  def unwrap_list(block):
      node = OrgNode(NodeType.LIST)

      node.ordered = (type(block) is pdt.OrderedList)

      if node.ordered:
          node.start = block[0][0]
          node.style = str(block[0][1])[:-2] # Strip trailing parens
          node.delim = str(block[0][2])[:-2] # ""
          i = 1
      else:
          i = 0

      for item in block[i]:
          item_node = OrgNode(NodeType.ITEM)
          item_node.children = unwrap_blocks(item)

      return node

#+end_src

**** TODO More testing of other cases that emit RawBlock (see Pandoc source code)

=RawBlock= objects contain their =Format= and associated =Text=. This
gets emitted by unhandled meta lines (lines starting with "#+").

#+begin_src python :noweb-ref Function definitions
  def unwrap_rawblock(block):
      assert(block[0][0] == 'org')

      matches = regex_match(r'#\+(\w+):\s+(.+)', block[1])
      assert(matches is not None)

      node = OrgNode(NodeType.META)
      node.key = matches[0].lower()
      node.value = matches[1]

      return node

#+end_src

#+begin_src python :noweb-ref Function definitions
  def unwrap_textblock(block):
      node = OrgNode(NodeType.TEXT)
      node.children = unwrap_blocks(block[0])

      node.strong = (type(block) is pdt.Strong)
      node.emph = (type(block) is pdt.Emph)

      return node

#+end_src

#+begin_src python :noweb-ref Function definitions
  def unwrap_token(block):
      node = OrgNode(NodeType.TOKN)

      if type(block) is pdt.Str:
          node.text = block[0]
      else:
          node.text = ' '

      return node

#+end_src

Finally, unwrapping a block consists of looking up the block type's
unwrapper in our map and applying it.

#+begin_src python :noweb-ref Function definitions
  <<Pandoc type unwrapping map>>

  def unwrap_block(block):
      pandoc_type = type(block)

      if pandoc_type not in pandoc_type_map:
          raise TypeError(f'Unhandled block type: {pandoc_type}')

      node = pandoc_type_map[pandoc_type](block)

      return node

#+end_src

** Generating the page content

**** TODO Auto-insert page title element
**** DONE Replace pandoc.write() with custom writer for better output formatting and control

Now that the Org file has been parsed into an AST, the AST can be
converted to HTML representing the page content by visiting each node
in the AST node list.

#+name: Generate page content from AST
#+begin_src python
  page_content = ast_to_html(ast)
#+end_src

**** TODO "Prettify" the HTML output (newlines & indentation)

#+begin_src python :noweb-ref Function definitions
  def ast_to_html(ast):
      headings = []

      <<Process AST nodes>>

      <<Generate table of contents>>

      html = '<div id="table-of-contents">' + toc + '</div>' + \
             '<div id="content">' + content + '</div>'

      return html

#+end_src

*** Processing AST nodes

Similarly to the way parsing was handled, each node type will need its
own case, with support for recursively converting children.

**** TODO Better method for stripping tags than hard-coded values

#+name: Process AST nodes
#+begin_src python
  content = ''
  for node in ast.nodes:
      node_html = render_node(node)
      if node.type_ == NodeType.HEAD:
          headings.append((node.level, node_html[4:-5]))
      content += node_html
#+end_src

#+begin_src python :noweb-ref Function definitions
  def render_nodes(nodes):
      html = ''
      for node in nodes:
          html += render_node(node)
      return html

#+end_src

The strategy for rendering the page's contents is similar to that for
generating the AST - define a map from node type to its corresponding
render function.

#+name: HTML render map
#+begin_src python
  html_render_map = {
      NodeType.CODE: render_code,
      NodeType.HEAD: render_heading,
      NodeType.ITEM: lambda node: render_default(node, 'li'),
      NodeType.LINK: render_link,
      NodeType.LIST: render_list,
      NodeType.META: render_ignore,
      NodeType.PARA: lambda node: render_default(node, 'p'),
      NodeType.SPAN: render_ignore,
      NodeType.TEXT: render_text,
      NodeType.TODO: render_ignore,
      NodeType.TOKN: render_token,
  }
#+end_src

**** TODO Add figcaption for named blocks

#+begin_src python :noweb-ref Function definitions
  def render_code(node):
      text = html_escape(node.text)

      html = f'<code>{text}</code>'
      if not node.inline:
          html = f'<figure><pre>{html}</pre></figure>'

      return html

#+end_src

#+begin_src python :noweb-ref Function definitions
  def render_default(node, tag, **kwargs):
      body = render_nodes(node.children)
      attrs = ''.join([f' {k}="{v}"' for k,v in kwargs.items()])
      return f'<{tag}{attrs}>{body}</{tag}>'

#+end_src

#+begin_src python :noweb-ref Function definitions
  def render_heading(node):
      tag = f'h{node.level}'
      return render_default(node, tag)

#+end_src

**** TODO Detect links to other Org files and convert appropriately
**** TODO Open external links in new tab & allow for separate styling

#+begin_src python :noweb-ref Function definitions
  def render_link(node):
      return render_default(node, 'a', href=node.target)

#+end_src

**** TODO Add support for start, style, & delim

#+begin_src python :noweb-ref Function definitions
  def render_list(node):
      tag = 'ol' if node.ordered else 'ul'
      return render_default(node, tag)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def render_ignore(node):
      return ''

#+end_src

#+begin_src python :noweb-ref Function definitions
  def render_text(node):
      if node.strong:
          return render_default(node, 'strong')
      if node.emph:
          return render_default(node, 'em')
      return render_nodes(node.children)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def render_token(node):
      return html_escape(node.text)

#+end_src

**** TODO Merge logic for parent tags
**** DONE Use integer constants instead of strings
**** DONE Remove soft breaks from AST entirely

#+begin_src python :noweb-ref Function definitions
  <<HTML render map>>

  def render_node(node):
      if node.type_ not in html_render_map:
          raise TypeError(f'Unhandled node type: {node.type_}')

      html = html_render_map[node.type_](node)

      return html

#+end_src

*** Generating the table of contents

#+name: Generate table of contents
#+begin_src python
  toc = '<h1>Table of Contents</h1>'
  prev_level = 0
  for level, text in headings:
      if level > prev_level:
          toc += '<ul><li>' * (level - prev_level)
      else:
          if level < prev_level:
              toc += '</li></ul>' * (prev_level - level)
          toc += '</li><li>'
      toc += text
      prev_level = level
  toc += '</li></ul>' * prev_level
#+end_src

** Populating the HTML template

When it comes time to actually render a page, we use the Jinja
=Environment= created earlier to load the template (AFAIK Jinja
handles caching for us), then use the template to render the final
output.

#+begin_src python :noweb-ref Function definitions
  def render_page(template, *args, **kwargs):
      jinja_template = jinja_env.get_template(template)
      return jinja_template.render(*args, **kwargs)

#+end_src

#+name: Create page from Template
#+begin_src python
  page_html = render_page('page.html', ast.metadata, content=page_content)
#+end_src

** Writing the page to file

#+begin_src python :noweb-ref Function definitions
  def write_to_file(fpath, string):
      with open(fpath, 'w+', encoding='utf-8') as f:
          f.write(string)

#+end_src

#+name: Write page to file
#+begin_src python
  url = fname + '.html'
  outpath = path_join(BUILD_DIR, url)
  write_to_file(outpath, page_html)

  ast.metadata['url'] = url
  pages.append(ast.metadata)
#+end_src

* Generating the home page

From the Python side, generating the home page is as simple as passing
the list of pages generated as a template argument.

**** TODO Add section detail index.html template design
**** TODO Is the title parameter really necessary?

#+name: Generate home page
#+begin_src python
  homepage_html = render_page('index.html', title='Home', pages=pages)
  outpath = path_join(BUILD_DIR, 'index.html')
  write_to_file(outpath, homepage_html)
#+end_src

* Exporting static files

Lastly, static files (those that should be exported directly, without
any further processing, such as stylesheets) must be copied to the
build directory.

**** TODO Add link to "Preparing the build directtory"

(Again, this amounts to a couple of utility function calls.)

#+begin_src python :noweb-ref Global constants
  STYLES_DIR = 'styles'
#+end_src

#+name: Export static files
#+begin_src python
  outdir = path_join(BUILD_DIR, STYLES_DIR)
  copy_dir(STYLES_DIR, outdir)
#+end_src
