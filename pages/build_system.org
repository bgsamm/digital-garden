:PROPERTIES:
:Title: Build system
:Author: pjsamm
:Date: 2025-12-26
:END:

#+OPTIONS: H:5

#+PROPERTY: header-args    :noweb yes
#+PROPERTY: header-args+   :eval never-export

**** TODO Better handling of heading export level setting
**** TODO Incorporate Jinja templates as literate programs
**** TODO Organize this page!!

* Overview

This page details the source code for the build system used to
generate this site. For a more general overview of this site's
structure, see [[file:site_overview.org][Site Overview]].

The build system is implemented as a Python script, which generates a
static site from Emacs [[https://orgmode.org/][Org]] files using [[https://boisgera.github.io/pandoc/][Pandoc]] to convert said files to
HTML, and [[https://jinja.palletsprojects.com/en/stable/][Jinja]] for generating pages from templates.

**** TODO Link to "wrap your dependencies" design principle

While it would be possible to use Pandoc from the CLI directly with
its built-in support for filters and templates, that approach couples
me more tightly to Pandoc, which I consider undesirable.

** Program outline

The overall structure of the program is as follows:

#+begin_src python :tangle ../build.py
  <<Imports>>

  <<Global constants>>

  <<Function definitions>>

  <<Prepare build directory>>

  <<Initialize Jinja>>

  <<Process org files>>

  <<Generate home page>>

  <<Export static files>>
#+end_src

**** DONE Add section for pre-build setup

* Utility functions

The following are a collection of utility functions that will be
useful throughout the build script.

** File system utilities

**** TODO Add link to "wrap your dependencies" mantra

These functions primarily serve to wrap dependencies on the =os= and
=shutil= libraries.

#+begin_src python :noweb-ref Imports
  import os
#+end_src

#+begin_src python :noweb-ref Imports
  import shutil
#+end_src

#+begin_src python :noweb-ref Function definitions
  def path_join(*args):
      """Join several path elements together with the OS-appropriate
      path separator.
      """
      return os.path.join(*args)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def make_dir(path):
      """Create a directory (and all necessary parent directories)
      if it does not already exist.
      """
      os.makedirs(path, exist_ok=True)

#+end_src

#+begin_src python :noweb-ref Function definitions
  def empty_dir(root):
      """Delete the contents of a directory.
      """
      for itemname in os.listdir(root):
          itempath = os.path.join(root, itemname)
          if os.path.isdir(itempath):
              shutil.rmtree(itempath)
          else:
              os.remove(itempath)
#+end_src

#+begin_src python :noweb-ref Function definitions
  def copy_dir(indir, outdir):
      """Copy the contents of one directory to another.
      """
      shutil.copytree(indir, outdir, dirs_exist_ok=True)

#+end_src

* Preparing the build environment

Before the actual build process can begin, some initial setup must be
performed. First, the build directory must be prepared, and second, a
Jinja environment must be created.

** Preparing the build directory

If the build directory does not exist, it must be created; if it
does exist, its contents must be deleted (to ensure a deleted, moved,
or renamed "zombie" page does not persist between builds).

(This step is trivialized by the utility functions defined above.)

#+begin_src python :noweb-ref Global constants
  BUILD_DIR = 'build'
#+end_src

#+name: Prepare build directory
#+begin_src python
  make_dir(BUILD_DIR)
  empty_dir(BUILD_DIR)
#+end_src

** Initializing Jinja

**** TODO Remove file prefix from link once intra-file links supported

Jinja uses an =Environment= object as a high-level API for configuring
and loading templates. This is created as a global variable for later
use (see [[file:build_system.org::*Populating the HTML template][Populating the HTML template]]) and is set to load templates
from a file system directory and trim whitespace from template blocks
(see [[https://jinja.palletsprojects.com/en/stable/api/#high-level-api][documentation]]).

**** TODO Determine why the library is called jinja*2*

#+begin_src python :noweb-ref Imports
  import jinja2
#+end_src

#+begin_src python :noweb-ref Global constants
  TEMPLATES_DIR = 'templates'
#+end_src

#+name: Initialize Jinja
#+begin_src python
  jinja_env = jinja2.Environment(
      loader=jinja2.FileSystemLoader(TEMPLATES_DIR),
      trim_blocks=True,
      lstrip_blocks=True
  )
#+end_src

* Processing Org files

To start, we must walk the directory containing our Org files and process each one.

#+begin_src python :noweb-ref Global constants
  PAGES_DIR = 'pages'
#+end_src

**** TODO More advanced/robust filtering

#+begin_src python :noweb-ref Function definitions
  def walk_directory(root, extension='*'):
      for dirpath, dirnames, filenames in os.walk(root):
          for filename in filenames:
              fname, ext = os.path.splitext(filename)
              if extension == '*' or ext == extension:
                  yield dirpath, fname, ext

#+end_src

#+name: Process org files
#+begin_src python
  pages = []
  for dirpath, fname, ext in walk_directory(PAGES_DIR, extension='.org'):
      <<Process org file>>
#+end_src

Processing an Org file involves parsing it into an abstract syntax
tree, converting that tree into an HTML string, then using that HTML
string (and any other relevant metadata) to populate a static page
template.

#+name: Process org file
#+begin_src python
  <<Parse org file into AST>>

  <<Generate page content from AST>>

  <<Create page from template>>

  <<Write page to file>>
#+end_src

** Parsing an Org file

**** TODO Insert link to "wrap dependencies" mantra

Currently, I am using Pandoc to perform the initial reading and
parsing of an Org file. I still perform a second filtering pass over
its output, however, both to keep from exposing its types to the rest
of the build system, and to gain greater control over the final
representation since things like to-do's are not handled well
out-of-the-box.

#+name: Parse org file into AST
#+begin_src python
  fpath = path_join(dirpath, fname + ext)
  ast = parse_org_file(fpath)

  metadata = ast[0]
#+end_src

#+begin_src python :noweb-ref Imports
  import pandoc
#+end_src

#+begin_src python :noweb-ref Function definitions
  def parse_org_file(fpath):
      ast = pandoc.read(file=fpath)

      <<Unwrap metadata>>

      <<Unwrap blocks>>

      return tuple(ast)

#+end_src

**** TODO Link to org-mode documentation on property drawers
**** TODO Link to pandoc Python documentation on types

Every Org file in this repository starts with a property drawer that
defines its metadata, like title, author, date, etc. This is stored as
the first element of the root =Pandoc= object, as a =Meta= object
containing a dictionary of (=str=, =MetaString=) pairs.

#+name: Unwrap metadata
#+begin_src python
  # Unwrap 'Meta' object
  metadata = ast[0][0]
  for k, v in metadata.items():
      # Unwrap 'MetaString' object
      metadata[k] = v[0]
  
  ast[0] = metadata
#+end_src

The second element of the root =Pandoc= object is a list of =Block=
objects, which represent each of the individual blocks in the Org file
as one of several different subtypes (e.g. =Header=, =Para=,
=CodeBlock=, etc.). Filters for each block type are added and expanded
on an as-needed basis.

#+name: Unwrap blocks
#+begin_src python
  ast[1] = unwrap_blocks(ast[1])
#+end_src

#+begin_src python :noweb-ref Function definitions
  def unwrap_blocks(blocks):
      return [unwrap_block(block) for block in blocks]

#+end_src

**** TODO Order type checks alphabetically
**** TODO Determine whether 'tokens' is really the appropriate term

#+begin_src python :noweb-ref Function definitions
  def unwrap_block(block):
      pandoc_type = type(block)
      if pandoc_type is pandoc.types.RawBlock:
          <<Unwrap RawBlock>>
      elif pandoc_type is pandoc.types.Header:
          <<Unwrap Header>>
      elif pandoc_type is pandoc.types.Para:
          node_type = 'paragraph'
          node_attrs = { 'children': unwrap_blocks(block[0]) }
      elif pandoc_type is pandoc.types.Plain:
          node_type = 'plain-text'
          node_attrs = { 'children': unwrap_blocks(block[0]) }
      elif pandoc_type is pandoc.types.Strong:
          node_type = 'strong-text'
          node_attrs = { 'children': unwrap_blocks(block[0]) }
      elif pandoc_type is pandoc.types.Emph:
          node_type = 'emphasized-text'
          node_attrs = { 'children': unwrap_blocks(block[0]) }
      elif pandoc_type is pandoc.types.OrderedList:
          <<Unwrap OrderedList>>
      elif pandoc_type is pandoc.types.CodeBlock:
          <<Unwrap CodeBlock>>
      elif pandoc_type is pandoc.types.Code:
          <<Unwrap Code>>
      elif pandoc_type is pandoc.types.Link:
          <<Unwrap Link>>
      elif pandoc_type is pandoc.types.Span:
          <<Unwrap Span>>
      elif pandoc_type is pandoc.types.Str:
          node_type = 'string'
          node_attrs = { 'text': block[0] }
      elif pandoc_type is pandoc.types.Space:
          node_type = 'space'
          node_attrs = {}
      elif pandoc_type is pandoc.types.SoftBreak:
          node_type = 'soft-break'
          node_attrs = {}
      else:
          raise TypeError(f'Unhandled block type: {pandoc_type}')

      <<Special case for TODO items>>

      return (node_type, node_attrs)

#+end_src

Because =TODO= items are represented in an Org mode using the same
syntax as headings, they end up getting parsed as a =Span= in either a
=Header= or a =Para= object's =Inline= tokens (since Pandoc exports
headings deeper than =org-export-headline-levels= as paragraphs).

Additionally, there appears to be a bug in the way Pandoc handles an
ordered list following one or more TODO items - it groups the TODOs in
an ordered list, then adds the following ordered list as a sublist.

To address these issues, a special case is added to catch such =TODO=
items and convert them to the proper node type.

**** TODO Clean up TODO detection/unwrapping logic

#+name: Special case for TODO items
#+begin_src python
  if node_type == 'heading' or node_type == 'paragraph':
      children = node_attrs['children']
      assert(len(children) > 0)
      first_child_type, first_child_attrs = children[0]
      if first_child_type == 'span' and first_child_attrs['is-todo']:
          node_type = 'todo-item'
          children[0] = first_child_attrs['children'][0]
#+end_src

=RawBlock= objects contain the block format (expected to be 'org') and
the block text. All we care about is the text, which we perform a
regular expression match on to determine the raw block's type.

#+begin_src python :noweb-ref Imports
  import re
#+end_src

#+begin_src python :noweb-ref Function definitions
  def regex_match(pattern, string):
      match_obj = re.match(pattern, string)
      if match_obj is not None:
          return match_obj.groups()
      return None

#+end_src

**** TODO Determine what directives beside 'property' get emitted by Pandoc

#+name: Unwrap RawBlock
#+begin_src python
    assert(block[0][0] == 'org')
    matches = regex_match(r'#\+(\w+):\s+(.+)', block[1])
    assert(matches is not None)
    node_type = 'org-directive'
    node_attrs = {
        'type': matches[0].lower(),
        'value': matches[1]
    }
#+end_src

=Header= objects contain the header level (1, 2, 3, etc.), an =Attr=
tuple of the form (id, classes, attributes), and then a list
representing the parsed header tokens (type =Inline=). These must be
unwrapped recursively.

**** TODO Verify the class and attribute lists are unused

#+name: Unwrap Header
#+begin_src python
  assert(block[1][1] == [] and block[1][2] == [])
  node_type = 'heading'
  node_attrs = {
      'level': block[0],
      'children': unwrap_blocks(block[2])
  }
#+end_src

An =OrderedList= contains a tuple of list attributes of the form
(start, style, delim), then a list of the list's items (each of which
is itself a list of blocks).

#+name: Unwrap OrderedList
#+begin_src python
  node_type = 'ordered-list'
  node_attrs = {
      'start': block[0][0],
      'style': str(block[0][1])[:-2], # Strip trailing parens
      'delim': str(block[0][2])[:-2], # ""
      'children': [(
          'list-item',
          { 'children': unwrap_blocks(item) }
      ) for item in block[1]]
  }
#+end_src

Code blocks are represented by =CodeBlock= objects, which consist of
an =Attr= tuple and the contained code (text). The language is
specified in the class list of the =Attr= tuple.

**** TODO Determine whether attributes list contains anything useful
**** TODO Verify language is only element of class list

#+name: Unwrap CodeBlock
#+begin_src python
  assert(len(block[0][1]) == 1)
  node_type = 'code-block'
  node_attrs = {
      'name': block[0][0],
      'language': block[0][1][0],
      'text': block[1]
  }
#+end_src

Inline code blocks are represented by =Code= objects and consist of an
=Attr= tuple and the contained code (text).

**** TODO Determine significance of 'verbatim' class
**** TODO Verify rest of =Attr= tuple goes unused

#+name: Unwrap Code
#+begin_src python
  assert(block[0][0] == '' and block[0][2] == [])
  assert(len(block[0][1]) == 1 and block[0][1][0] == 'verbatim')
  node_type = 'inline-code'
  node_attrs = {
      'text': block[1]
  }
#+end_src

=Link= objects contain an =Attr= tuple (currently ignored), a list of
=Inline= tokens (the link text), and the link's =Target= (a 2-tuple).

I am currently ignoring the second element of the =Target=, which I
/believe/ to be a title or description and which is likely unused by
Org files.

**** TODO Verify the Attr tuple is unused
**** TODO Verify that second element of Target is title (and unused)

#+name: Unwrap Link
#+begin_src python
  assert(block[0] == ('', [], []))
  assert(block[2][1] == '')
  node_type = 'link'
  node_attrs = {
      'children': unwrap_blocks(block[1]),
      'target': block[2][0]
  }
#+end_src

=Span= objects consist of an =Attr= tuple and a list of =Inline=
tokens, much like a header. This gets emitted for =TODO= items, in
which case the class list in the =Attr= tuple will be =['todo',
'TODO']=.

**** TODO Determine under what other circumstances Span gets emitted
**** TODO Add support for intra-file links ('spurious-link' class)
**** TODO Check how 'DONE' tasks get emitted

#+name: Unwrap Span
#+begin_src python
  node_type = 'span'
  node_attrs = {
      'is-todo': 'todo' in block[0][1] or 'done' in block[0][1],
      'children': unwrap_blocks(block[1])
  }
#+end_src

** Generating the page content

**** TODO Auto-insert page title element
**** DONE Replace pandoc.write() with custom writer for better output formatting and control

Now that the Org file has been parsed into an AST, the AST can be
converted to HTML representing the page content by visiting each node
in the AST node list.

#+name: Generate page content from AST
#+begin_src python
  page_content = ast_to_html(ast)
#+end_src

**** TODO "Prettify" the HTML output (newlines & indentation)

#+begin_src python :noweb-ref Function definitions
  def ast_to_html(ast):
      headings = []

      content = ''
      <<Process AST nodes>>

      toc = '<h1>Table of Contents</h1>'
      <<Generate table of contents>>

      html = '<div id="table-of-contents">' + toc + '</div>' + \
             '<div id="content">' + content + '</div>'

      return html

#+end_src

*** Processing AST nodes

Similarly to the way parsing was handled, each node type will need its
own case, with support for recursively converting children.

**** TODO Better method for stripping tags than hard-coded values

#+name: Process AST nodes
#+begin_src python
  for node in ast[1]:
      node_html = ast_node_to_html(node)
      if node[0] == 'heading':
          headings.append((node[1]['level'], node_html[4:-5]))
      content += node_html
#+end_src

#+begin_src python :noweb-ref Function definitions
  def html_escape(s):
      return s.replace('&', '&amp;') \
              .replace('<', '&lt;') \
              .replace('>', '&gt;')

#+end_src

#+begin_src python :noweb-ref Function definitions
  def ast_nodes_to_html(nodes):
      html = ''
      for node in nodes:
          html += ast_node_to_html(node)
      return html

#+end_src

**** TODO Use integer constants instead of strings
**** TODO Remove soft breaks from AST entirely?

#+begin_src python :noweb-ref Function definitions
  def ast_node_to_html(node):
      html = ''

      node_type, node_attrs = node

      if node_type == 'org-directive':
          pass
      elif node_type == 'todo-item':
          pass
      elif node_type == 'heading':
          <<Heading to HTML>>
      elif node_type == 'paragraph':
          <<Paragraph to HTML>>
      elif node_type == 'plain-text':
          html += ast_nodes_to_html(node_attrs['children'])
      elif node_type == 'strong-text':
          <<Strong text to HTML>>
      elif node_type == 'emphasized-text':
          <<Emphasized text to HTML>>
      elif node_type == 'ordered-list':
          <<Ordered list to HTML>>
      elif node_type == 'list-item':
          <<List item to HTML>>
      elif node_type == 'inline-code':
          <<Inline code to HTML>>
      elif node_type == 'code-block':
          <<Code block to HTML>>
      elif node_type == 'link':
          <<Link to HTML>>
      elif node_type == 'string':
          html += html_escape(node_attrs['text'])
      elif node_type == 'space':
          html += ' '
      elif node_type == 'soft-break':
          html += ' '
      else:
          print(node)
          raise TypeError(f'Unhandled node type: {node_type}')

      return html

#+end_src

**** TODO Merge logic for parent tags

#+name: Heading to HTML
#+begin_src python
  n = node_attrs['level']
  html += f'<h{n}>'
  html += ast_nodes_to_html(node_attrs['children'])
  html += f'</h{n}>'
#+end_src

#+name: Paragraph to HTML
#+begin_src python
  html += '<p>'
  html += ast_nodes_to_html(node_attrs['children'])
  html += '</p>'
#+end_src

#+name: Strong text to HTML
#+begin_src python
  html += '<strong>'
  html += ast_nodes_to_html(node_attrs['children'])
  html += '</strong>'
#+end_src

#+name: Emphasized text to HTML
#+begin_src python
  html += '<em>'
  html += ast_nodes_to_html(node_attrs['children'])
  html += '</em>'
#+end_src

**** TODO Add support for start, style, & delim

#+name: Ordered list to HTML
#+begin_src python
  html += '<ol>'
  html += ast_nodes_to_html(node_attrs['children'])
  html += '</ol>'
#+end_src

#+name: List item to HTML
#+begin_src python
  html += '<li>'
  html += ast_nodes_to_html(node_attrs['children'])
  html += '</li>'
#+end_src

**** TODO Detect links to other Org files and convert appropriately
**** TODO Open external links in new tab & allow for separate styling

#+name: Link to HTML
#+begin_src python
  target = node_attrs['target']
  html += f'<a href="{target}">'
  html += ast_nodes_to_html(node_attrs['children'])
  html += '</a>'
#+end_src

#+name: Inline code to HTML
#+begin_src python
  html += '<code>'
  html += html_escape(node_attrs['text'])
  html += '</code>'
#+end_src

#+name: Code block to HTML
#+begin_src python
  name = node_attrs['name']
  html += '<figure>'
  if len(name) > 0:
      html += '<figcaption>'
      html += html_escape(name)
      html += '</figcaption>'
  html += '<pre><code>'
  html += html_escape(node_attrs['text'])
  html += '</code></pre></figure>'
#+end_src

*** Generating the table of contents

#+name: Generate table of contents
#+begin_src python
  prev_level = 0
  for level, text in headings:
      if level > prev_level:
          toc += '<ul><li>' * (level - prev_level)
      else:
          if level < prev_level:
              toc += '</li></ul>' * (prev_level - level)
          toc += '</li><li>'
      toc += text
      prev_level = level
  toc += '</li></ul>' * prev_level
#+end_src

** Populating the HTML template

When it comes time to actually render a page, we use the Jinja
=Environment= created earlier to load the template (AFAIK Jinja
handles caching for us), then use the template to render the final
output.

#+begin_src python :noweb-ref Function definitions
  def render_page(template, *args, **kwargs):
      jinja_template = jinja_env.get_template(template)
      return jinja_template.render(*args, **kwargs)

#+end_src

#+name: Create page from Template
#+begin_src python
  page_html = render_page('page.html', metadata, content=page_content)
#+end_src

** Writing the page to file

#+begin_src python :noweb-ref Function definitions
  def write_to_file(fpath, string):
      with open(fpath, 'w+', encoding='utf-8') as f:
          f.write(string)

#+end_src

#+name: Write page to file
#+begin_src python
  url = fname + '.html'
  outpath = path_join(BUILD_DIR, url)
  write_to_file(outpath, page_html)

  metadata['url'] = url
  pages.append(metadata)
#+end_src

* Generating the home page

Last but not least, I generate the home page.

#+name: Generate home page
#+begin_src python
  homepage_html = render_page('index.html', title='Home', pages=pages)
  outpath = path_join(BUILD_DIR, 'index.html')
  write_to_file(outpath, homepage_html)
#+end_src

* Exporting static files

Lastly, static files (those that should be exported directly as-is,
without any further processing, such as stylesheets) must be copied to
the build directory.

**** TODO Add link to "Preparing the build directtory"

(Again, this amounts to a couple of utility function calls.)

#+begin_src python :noweb-ref Global constants
  STYLES_DIR = 'styles'
#+end_src

#+name: Export static files
#+begin_src python
  outdir = path_join(BUILD_DIR, STYLES_DIR)
  copy_dir(STYLES_DIR, outdir)
#+end_src
